#!/usr/bin/env python
# -*- coding: utf-8 -*-
import ast
import imp
import sys

from stypy import contexts
from stypy.errors import type_error
from stypy.log import logging_console
from stypy.reporting.localization import Localization
from stypy.sgmc.sgmc_main import SGMC, always_regenerate_files
from stypy.type_inference_programs.source_code_writer import write_python_source_code
from stypy.visitor.python_src_generation.python_src_generator_visitor import PythonSrcGeneratorVisitor
from stypy.visitor.python_src_print.python_src_print_visitor import dump_ast
from stypy.visitor.type_inference import type_inference_visitor
from stypy.visitor.type_inference.desugaring import class__init__visitor
from stypy.visitor.type_inference.desugaring import class_attributes_visitor
from stypy.visitor.type_inference.desugaring import idiom_conversion_visitor
from stypy.visitor.type_inference.desugaring import multiple_assignments_visitor
from stypy.visitor.type_inference.desugaring import relative_import_visitor
from stypy.visitor.type_inference.visitor_utils.stypy_functions import default_module_type_store_var_name, \
    default_type_error_var_name, default_type_warning_var_name
from stypy_parameters import *

"""
                    STYPY MAIN FILE. LAUNCHES THE TYPE INFERENCE PROGRAM GENERATION
"""

"""
Assigning log functions
"""
info = logging_console.info
ok = logging_console.ok
error = logging_console.error
warning = logging_console.warning

"Null log functions when log is disabled"


def f():
    pass


reset_logs = f


def void_print_func(*args):
    pass


class Stypy(object):
    """
    Main class for the stypy type-inference Python system. It controls all the interaction with Python source code files
    and stypy runtime. From a Python source file it:
    - Parses the file and generates an equivalent type-inference program. This program can be executed to tell the
    original program type errors
    - Optionally generates a type annotated Python source file identical to the original one but with types assigned
    to all its variables. It is the same functionality that stypy provides, but written into suitable places of a copy
    of the original file instead of reporting types and type errors via console. It is helpful for debuggin purposes
    and in the future it can be adapted to follow PEP 0484 (Type hints) https://www.python.org/dev/peps/pep-0484/
    - Optionally generates a version of the original program that calculates a table of variables and its runtime types.
    It does not work on 100% of the cases, its implementation is rather basic and may fail with some program constructs,
    but it help to generate tables of types that later on can be used to unit test generated type inference programs.
    """

    @staticmethod
    def __file_exist_in_sgmc(file_name):
        """
        Determines if a file is already in the SGMC (Stypy Global Module Cache)
        :param file_name:
        :return:
        """
        return os.path.exists(file_name) and not always_regenerate_files

    # ##################################### PRIVATE METHODS ######################################

    def __read_new_ast_from_file(self):
        """
        Reads the AST of the source Python file
        :return:
        """
        return ast.parse(self.original_program_src)

    def __get_original_source_file_ast(self):
        """
        Returns the AST of the source Python file
        :return:
        """
        return self.original_ast_tree

    @staticmethod
    def __run_program(file_path):
        """
        Runs a Python program importing its source code and providing fresh locals() and globals() environments. It is
        used to execute the various Python programs that stypy generates if needed.
        :param file_path:
        :return:
        """
        my_globals = globals()
        my_globals["__file__"] = file_path

        my_locals = dict()

        dirname = os.path.dirname(file_path)
        source_file = file_path.split('/')[-1][0:-3]

        sys.path.append(dirname)
        __import__(source_file, my_globals, my_locals)

    def __run_type_inference_program(self, file_path):
        """
        Runs a type inference program generated by stypy by importing it. It provides a fresh globals environment
        with initialized __file__ and __name__ environment variables, an empty locals() environment and time-measuring
        instrumentation. At the end of the execution, it extracts the generated type store, the type errors and the
        type warnings that have been detected.
        :param file_path: Program to run
        :return:
        """
        source_file = file_path.split('/')[-1][0:-3]

        if not self.is_main:
            self.module = imp.load_source(source_file, file_path)
        else:
            with open(file_path) as fil:
                self.module = imp.load_source('__main__', file_path, fil)

        try:
            # After running the program, extract type inference data
            self.analyzed_program_type_store = getattr(self.module, default_module_type_store_var_name)
            self.analyzed_program_errors = getattr(self.module, default_type_error_var_name)
            self.analyzed_program_warnings = getattr(self.module, default_type_warning_var_name)
        except:
            self.analyzed_program_type_store = None
            self.analyzed_program_errors = []
            self.analyzed_program_warnings = []

    @classmethod
    def __is_file_suitable_for_autocalculate_types(cls, file_path):
        """
        Determines if a source file is suitable to generate a derived runtime type calculation program. Negative
        tests (those that fail at runtime) are not suitable for it because they cannot be fully executed to calculate
        the runtime type of its variables. Negative test program name begins with "error_" by convention.
        :param file_path: File to test
        :return:
        """
        return "error_" not in file_path

    @classmethod
    def __configure_stypy_output(cls, verbose):
        """
        Configures whether output are displayed on console or are not displayed
        :param verbose:
        :return:
        """
        global info
        global ok
        global error

        if verbose:
            info = sys.stdout.write
            ok = sys.stdout.write
            error = sys.stderr.write
        else:
            info = void_print_func
            ok = void_print_func
            error = void_print_func

    # ##################################### PUBLIC METHODS ######################################

    def create_instance(self, source_file_path):
        """
        Creates a new instance of the Stypy class using the values of the current stypy instance regarding Python
        interpreter, output verbosity and optional file generation. Its purpose is to "spawn" a new Stypy object
        for a different source file with the same configuration quickly, in order to parse Python source modules
        that are loaded by the main parsed program
        :param source_file_path:
        :return:
        """
        return Stypy(source_file_path, self.python_exe, self.verbose, self.generate_type_data_file)

    def __init__(self, source_file_path,
                 python_exe=PYTHON_EXE,
                 verbose=False,
                 generate_type_data_file=False,
                 generate_type_annotated_program=False,
                 show_ast=False,
                 type_inference_program_file=None,
                 is_main=False):
        """
        Buils a new Stypy type inference object instance for a certain source program. Creating an equivalent type
        inference program.
        :param source_file_path: Source program to process and calculate its type inference program
        :param python_exe: Python implementation to use (optional, initialized by default to the PYTHON_EXE stypy
        parameter)
        :param verbose: Output verbosity (True/False)
        :param generate_type_data_file: Optionally generate a type data file to perform unit testing over the
        generated type inference program. Defaults to False
        :param generate_type_annotated_program: Optionally generate a type annotated source file from the original one.
        Defaults to False
        :param show_ast: Display the AST of the processed source file. Defaults to False
        :return:
        """
        self.python_exe = python_exe
        self.validation_error = ""
        self.source_file_path = source_file_path

        file_ = open(self.source_file_path, 'r')
        self.original_program_src = file_.read()
        file_.close()

        self.type_inference_program_file = type_inference_program_file

        # Configure all suitable objects to use type annotation, that will be later used
        # to create type annotated source files. THIS HAS BEEN TEMPORALLY DISABLED
        # contexts.context.FunctionContext.annotate_types = generate_type_annotated_program
        # StandardWrapper.annotate_types = generate_type_annotated_program

        # Output configuration
        self.verbose = verbose
        Stypy.__configure_stypy_output(verbose)

        if not Stypy.__file_exist_in_sgmc(type_inference_program_file):
            try:
                # Read the program AST
                self.original_ast_tree = self.__read_new_ast_from_file()
            except Exception as exc:
                error("Python is unable to compile the input file '{0}':\n".format(self.source_file_path) + str(exc))
                sys.exit(-1)

            # Sequence of source visitors that will be applied over the original program AST. Those visitor transform
            # the program code in various ways, aiming to facilitate the type inference program generation when dealing
            # with some Python constructs. Visitors are processed in declaration order. The last one should be the
            # TypeInferenceGeneratorVisitor, that is in charge of generating the type inference program.
            self.visitors = [
                idiom_conversion_visitor.IdiomConversionVisitor(),
                multiple_assignments_visitor.MultipleAssignmentsDesugaringVisitor(),
                class_attributes_visitor.ClassAttributesVisitor(),
                class__init__visitor.ClassInitVisitor(),
                relative_import_visitor.RelativeImportVisitor(self.source_file_path),
                type_inference_visitor.TypeInferenceGeneratorVisitor(self.source_file_path.split('\\')[-1],
                                                                     self.original_program_src),
            ]

        # Member initialization
        self.type_inference_ast_tree = None
        self.type_inference_source_code = None
        self.generate_type_data_file = generate_type_data_file
        self.show_ast = show_ast
        self.generate_type_annotated_program = generate_type_annotated_program
        self.tinit = 0
        self.tend = 0
        self.is_main = is_main

        # Program analysis output results
        self.analyzed_program_type_store = None
        self.analyzed_program_errors = None
        self.analyzed_program_warnings = None

    def set_source_file_path(self, source_file_path):
        """
        Changes the source file of the program to be processed
        :param source_file_path: File path
        :return:
        """
        self.source_file_path = source_file_path
        file_ = open(self.source_file_path, 'r')
        self.original_program_src = file_.read()
        file_.close()

    # ##################################### ORIGINAL SOURCE FILE ######################################

    def get_original_source_file_ast(self):
        """
        Get the original source file AST tree optionally showing it
        :return:
        """
        if self.verbose:
            info("\nSTyPy: Calculating program AST...\n")
        original_ast = self.__get_original_source_file_ast()
        if self.show_ast:
            info(dump_ast(original_ast))

        return original_ast

    # ################################ TYPE DATA FILE AUTOGENERATION (DISABLED) ######################################

    # def get_type_data_autogeneration_ast(self):
    #     """
    #     Get the AST of the optionally generated runtime type data calculation program
    #     :return:
    #     """
    #     if not hasattr(self, "type_data_autogeneration_ast_tree"):
    #         return None
    #     return self.type_data_autogeneration_ast_tree
    #
    # def get_type_data_autogeneration_program_source_code(self):
    #     """
    #     Get the source code of the optionally generated runtime type data calculation program
    #     :return:
    #     """
    #     if not hasattr(self, "type_generation_source_code"):
    #         return None
    #
    #     if self.type_generation_source_code is None:
    #         self.type_generation_source_code = PythonSrcGeneratorVisitor(
    #             self.get_type_data_autogeneration_ast()).generate_code()
    #
    #     return self.type_generation_source_code

    # def create_automatic_type_data_autogenerator_program(self):
    #     """
    #     Creates a runtime type data calculation program derived from the original one, used for unit testing
    #     :return:
    #     """
    #     if os.path.exists(get_stypy_type_data_file_path(self.source_file_path)):
    #         return
    #
    #     info("\nSTyPy: Calculating automatic type information helper program AST...\n")
    #     tt_ast = self.get_type_data_autogeneration_ast()
    #     if tt_ast is None:
    #         return
    #     if self.show_ast:
    #         info(dump_ast(tt_ast))
    #
    #     info("\n\n")
    #
    #     info("\nSTyPy: Automatic type information helper program code:\n")
    #     tgen_source = self.get_type_data_autogeneration_program_source_code()
    #     info(tgen_source)
    #     write_python_source_code(get_stypy_type_data_autogenerator_program_file_path(self.source_file_path),
    #                              tgen_source)
    #
    #     if not os.path.exists(get_stypy_type_data_file_path(self.source_file_path)):
    #         self.__run_program(get_stypy_type_data_autogenerator_program_file_path(self.source_file_path))

    # ##################################### TYPE INFERENCE PROGRAM ######################################

    def get_type_inference_program_ast(self):
        """
        Get the generated type inference program AST
        :return:
        """
        if self.type_inference_ast_tree is None:
            self.type_inference_ast_tree = self.original_ast_tree

            # Apply each visitor in declaration order
            for visitor in self.visitors:
                if self.verbose:
                    info("USING '{0}' VISITOR\n".format(type(visitor).__name__))

                # Visitor is a NodeVisitor that generate a new tree from the original one without changing it.
                # Replace the current one for the next iteration once finished
                if isinstance(visitor, ast.NodeVisitor):
                    temp_tree = visitor.visit(self.type_inference_ast_tree)
                    self.type_inference_ast_tree = temp_tree

                    if isinstance(visitor, multiple_assignments_visitor.MultipleAssignmentsDesugaringVisitor):
                        while visitor.performed_transformations:
                            visitor.reset()
                            temp_tree = visitor.visit(self.type_inference_ast_tree)
                            self.type_inference_ast_tree = temp_tree
                else:
                    # Modify nodes of the existing tree (visitor is a NodeTransformer)
                    visitor.visit(self.type_inference_ast_tree)

                if self.show_ast:
                    info(dump_ast(self.type_inference_ast_tree))
            try:
                # This is needed for proper source code generation from the generated AST tree
                ast.fix_missing_locations(self.type_inference_ast_tree)
            except Exception as ex:
                pass

        return self.type_inference_ast_tree

    def get_type_inference_program_source_code(self):
        """
        Generates the source code for the type inference program, once its AST has been calculated
        :return:
        """
        if self.type_inference_source_code is None:
            self.type_inference_source_code = PythonSrcGeneratorVisitor(
                self.get_type_inference_program_ast(), self.type_inference_program_file).generate_code()

            for visitor in self.visitors:
                if isinstance(visitor, type_inference_visitor.TypeInferenceGeneratorVisitor):
                    self.type_inference_source_code += \
                        type_inference_visitor.TypeInferenceGeneratorVisitor.get_postfix_src_code()
                    break

        return self.type_inference_source_code

    def create_type_inference_program(self):
        """
        Perform the full cycle of generating the type inference program AST (get_type_inference_program_ast) -
        generate the source code from this AST (get_type_inference_program_source_code) - write this source code to a
        file (write_python_source_code). This method should be called when generating the type inference program from
        a Python source file, instead of the individual ones, provided in a public fashion just for logging purposes.
        :return:
        """
        if not self.__file_exist_in_sgmc(self.type_inference_program_file):
            if self.verbose:
                info("\nSTyPy: Calculating type inference program AST...\n")
            ti_ast = self.get_type_inference_program_ast()

            if self.show_ast:
                info(dump_ast(ti_ast))

            if self.verbose:
                info("\n\n")
                info("\nSTyPy: Type inference program source code:\n")

            tinf_source = self.get_type_inference_program_source_code()
            info(tinf_source)

            if self.type_inference_program_file is None:
                self.type_inference_program_file = get_stypy_type_inference_program_file_path(self.source_file_path)

            write_python_source_code(self.type_inference_program_file, tinf_source)

            SGMC.change_file_modification_time(self.source_file_path, self.type_inference_program_file)
            try:
                import py_compile
                py_compile.compile(self.type_inference_program_file)
                SGMC.change_file_modification_time(self.source_file_path, self.type_inference_program_file + "c")
            except:
                pass

    # ##################################### RUN TYPE INFERENCE ######################################

    def run_type_inference(self):
        """
        Runs the type inference program of the source represented by this Stypy object, generating a type data file
        (if it does not exist) in order to test the type inference results against these data, provided this option
        is enabled. Finally, it generates the equivalent type annotated program, if this option is enabled.
        :return:
        """
        if self.verbose:
            info("\nSTyPy: Running type inference program...\n")

        if not self.__file_exist_in_sgmc(self.type_inference_program_file):
            # Run the generated type inference program to look for errors
            original_file_path = os.path.dirname(self.source_file_path)

            if original_file_path not in sys.path:
                sys.path.append(original_file_path)

            if self.type_inference_program_file is None:
                file_to_execute = get_stypy_type_inference_program_file_path(self.source_file_path)
            else:
                file_to_execute = self.type_inference_program_file

            self.__run_type_inference_program(file_to_execute)

            if original_file_path in sys.path:
                sys.path.remove(original_file_path)
        else:
            self.__run_type_inference_program(self.type_inference_program_file)

        # Create a type annotated program from the original source file (DISABLED)
        # if self.generate_type_annotated_program:
        #     self.create_type_annotated_program()

        return self.module

    # def create_type_annotated_program(self):
    #     """
    #     Creates a type-annotated version of the analyzed Python program.
    #     :return:
    #     """
    #     my_type_store = self.get_analyzed_program_type_store()
    #     # Visit the source code with the analyzed program type store with the inferred types, so we can place type
    #     # annotations in the correct source lines
    #     annotator_visitor = TypeAnnotationVisitor(self.source_file_path, my_type_store)
    #
    #     annotated_tree = annotator_visitor.visit(self.__read_new_ast_from_file())
    #     if self.show_ast:
    #         info("Type annotated program AST: ")
    #         info(dump_ast(annotated_tree))
    #
    #     try:
    #         ast.fix_missing_locations(annotated_tree)
    #     except:
    #         pass
    #
    #     annotated_type_source_code = PythonSrcGeneratorVisitor(annotated_tree).generate_code()
    #     write_python_source_code(get_stypy_type_annotation_file_path(self.source_file_path),
    #                              annotated_type_source_code)
    #
    #     # Annotate the types of modules that the program uses
    #     for stypy_object in my_type_store.external_modules:
    #         stypy_object.create_type_annotated_program()

    def analyze(self):
        """
        Main stypy function. Performs all the steps to analyze the source file types in order
        """
        if self.verbose:
            info("Parsing file '" + self.source_file_path + "'\n")

        try:
            existing_ts = contexts.context.Context.get_current_active_context_for_module(self.source_file_path)
            if existing_ts is not None:
                self.analyzed_program_type_store = existing_ts
                return existing_ts
        except:
            pass

        # Obtain the AST of the source file
        # self.get_original_source_file_ast()

        # If a type data file have to be generated and the source file is suitable to do so, do it
        # if self.generate_type_data_file:
        #     if Stypy.__is_file_suitable_for_autocalculate_types(self.source_file_path):
        #         self.create_automatic_type_data_autogenerator_program()

        # Create the type inference program
        self.create_type_inference_program()

        try:
            return self.run_type_inference()
        except Exception as exc:
            return type_error.StypyTypeError(Localization.get_current(), exc.message)

    # ##################################### POST ANALYSIS DATA ######################################

    def get_analyzed_program_type_store(self):
        """
        Get the type store of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_type_store is None:
            self.analyze()

        return self.analyzed_program_type_store

    def get_analyzed_program_errors(self):
        """
        Get the type errors of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_errors is None:
            self.analyze()

        return self.analyzed_program_errors

    def get_analyzed_program_warnings(self):
        """
        Get the type warnings of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_warnings is None:
            self.analyze()

        return self.analyzed_program_warnings

    def get_last_type_checking_running_time(self):
        """
        Get the time spent on the last Python source file analysis
        :return:
        """
        return self.tend - self.tinit
