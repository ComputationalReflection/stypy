
# -*- coding: utf-8 -*-

"""
ORIGINAL PROGRAM SOURCE CODE:
1: '''
2: =========
3: Constants
4: =========
5: 
6: Numpy includes several constants:
7: 
8: %(constant_list)s
9: '''
10: #
11: # Note: the docstring is autogenerated.
12: #
13: from __future__ import division, absolute_import, print_function
14: 
15: import textwrap, re
16: 
17: # Maintain same format as in numpy.add_newdocs
18: constants = []
19: def add_newdoc(module, name, doc):
20:     constants.append((name, doc))
21: 
22: add_newdoc('numpy', 'Inf',
23:     '''
24:     IEEE 754 floating point representation of (positive) infinity.
25: 
26:     Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for
27:     `inf`. For more details, see `inf`.
28: 
29:     See Also
30:     --------
31:     inf
32: 
33:     ''')
34: 
35: add_newdoc('numpy', 'Infinity',
36:     '''
37:     IEEE 754 floating point representation of (positive) infinity.
38: 
39:     Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for
40:     `inf`. For more details, see `inf`.
41: 
42:     See Also
43:     --------
44:     inf
45: 
46:     ''')
47: 
48: add_newdoc('numpy', 'NAN',
49:     '''
50:     IEEE 754 floating point representation of Not a Number (NaN).
51: 
52:     `NaN` and `NAN` are equivalent definitions of `nan`. Please use
53:     `nan` instead of `NAN`.
54: 
55:     See Also
56:     --------
57:     nan
58: 
59:     ''')
60: 
61: add_newdoc('numpy', 'NINF',
62:     '''
63:     IEEE 754 floating point representation of negative infinity.
64: 
65:     Returns
66:     -------
67:     y : float
68:         A floating point representation of negative infinity.
69: 
70:     See Also
71:     --------
72:     isinf : Shows which elements are positive or negative infinity
73: 
74:     isposinf : Shows which elements are positive infinity
75: 
76:     isneginf : Shows which elements are negative infinity
77: 
78:     isnan : Shows which elements are Not a Number
79: 
80:     isfinite : Shows which elements are finite (not one of Not a Number,
81:     positive infinity and negative infinity)
82: 
83:     Notes
84:     -----
85:     Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
86:     (IEEE 754). This means that Not a Number is not equivalent to infinity.
87:     Also that positive infinity is not equivalent to negative infinity. But
88:     infinity is equivalent to positive infinity.
89: 
90:     Examples
91:     --------
92:     >>> np.NINF
93:     -inf
94:     >>> np.log(0)
95:     -inf
96: 
97:     ''')
98: 
99: add_newdoc('numpy', 'NZERO',
100:     '''
101:     IEEE 754 floating point representation of negative zero.
102: 
103:     Returns
104:     -------
105:     y : float
106:         A floating point representation of negative zero.
107: 
108:     See Also
109:     --------
110:     PZERO : Defines positive zero.
111: 
112:     isinf : Shows which elements are positive or negative infinity.
113: 
114:     isposinf : Shows which elements are positive infinity.
115: 
116:     isneginf : Shows which elements are negative infinity.
117: 
118:     isnan : Shows which elements are Not a Number.
119: 
120:     isfinite : Shows which elements are finite - not one of
121:                Not a Number, positive infinity and negative infinity.
122: 
123:     Notes
124:     -----
125:     Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
126:     (IEEE 754). Negative zero is considered to be a finite number.
127: 
128:     Examples
129:     --------
130:     >>> np.NZERO
131:     -0.0
132:     >>> np.PZERO
133:     0.0
134: 
135:     >>> np.isfinite([np.NZERO])
136:     array([ True], dtype=bool)
137:     >>> np.isnan([np.NZERO])
138:     array([False], dtype=bool)
139:     >>> np.isinf([np.NZERO])
140:     array([False], dtype=bool)
141: 
142:     ''')
143: 
144: add_newdoc('numpy', 'NaN',
145:     '''
146:     IEEE 754 floating point representation of Not a Number (NaN).
147: 
148:     `NaN` and `NAN` are equivalent definitions of `nan`. Please use
149:     `nan` instead of `NaN`.
150: 
151:     See Also
152:     --------
153:     nan
154: 
155:     ''')
156: 
157: add_newdoc('numpy', 'PINF',
158:     '''
159:     IEEE 754 floating point representation of (positive) infinity.
160: 
161:     Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for
162:     `inf`. For more details, see `inf`.
163: 
164:     See Also
165:     --------
166:     inf
167: 
168:     ''')
169: 
170: add_newdoc('numpy', 'PZERO',
171:     '''
172:     IEEE 754 floating point representation of positive zero.
173: 
174:     Returns
175:     -------
176:     y : float
177:         A floating point representation of positive zero.
178: 
179:     See Also
180:     --------
181:     NZERO : Defines negative zero.
182: 
183:     isinf : Shows which elements are positive or negative infinity.
184: 
185:     isposinf : Shows which elements are positive infinity.
186: 
187:     isneginf : Shows which elements are negative infinity.
188: 
189:     isnan : Shows which elements are Not a Number.
190: 
191:     isfinite : Shows which elements are finite - not one of
192:                Not a Number, positive infinity and negative infinity.
193: 
194:     Notes
195:     -----
196:     Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
197:     (IEEE 754). Positive zero is considered to be a finite number.
198: 
199:     Examples
200:     --------
201:     >>> np.PZERO
202:     0.0
203:     >>> np.NZERO
204:     -0.0
205: 
206:     >>> np.isfinite([np.PZERO])
207:     array([ True], dtype=bool)
208:     >>> np.isnan([np.PZERO])
209:     array([False], dtype=bool)
210:     >>> np.isinf([np.PZERO])
211:     array([False], dtype=bool)
212: 
213:     ''')
214: 
215: add_newdoc('numpy', 'e',
216:     '''
217:     Euler's constant, base of natural logarithms, Napier's constant.
218: 
219:     ``e = 2.71828182845904523536028747135266249775724709369995...``
220: 
221:     See Also
222:     --------
223:     exp : Exponential function
224:     log : Natural logarithm
225: 
226:     References
227:     ----------
228:     .. [1] http://en.wikipedia.org/wiki/Napier_constant
229: 
230:     ''')
231: 
232: add_newdoc('numpy', 'inf',
233:     '''
234:     IEEE 754 floating point representation of (positive) infinity.
235: 
236:     Returns
237:     -------
238:     y : float
239:         A floating point representation of positive infinity.
240: 
241:     See Also
242:     --------
243:     isinf : Shows which elements are positive or negative infinity
244: 
245:     isposinf : Shows which elements are positive infinity
246: 
247:     isneginf : Shows which elements are negative infinity
248: 
249:     isnan : Shows which elements are Not a Number
250: 
251:     isfinite : Shows which elements are finite (not one of Not a Number,
252:     positive infinity and negative infinity)
253: 
254:     Notes
255:     -----
256:     Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
257:     (IEEE 754). This means that Not a Number is not equivalent to infinity.
258:     Also that positive infinity is not equivalent to negative infinity. But
259:     infinity is equivalent to positive infinity.
260: 
261:     `Inf`, `Infinity`, `PINF` and `infty` are aliases for `inf`.
262: 
263:     Examples
264:     --------
265:     >>> np.inf
266:     inf
267:     >>> np.array([1]) / 0.
268:     array([ Inf])
269: 
270:     ''')
271: 
272: add_newdoc('numpy', 'infty',
273:     '''
274:     IEEE 754 floating point representation of (positive) infinity.
275: 
276:     Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for
277:     `inf`. For more details, see `inf`.
278: 
279:     See Also
280:     --------
281:     inf
282: 
283:     ''')
284: 
285: add_newdoc('numpy', 'nan',
286:     '''
287:     IEEE 754 floating point representation of Not a Number (NaN).
288: 
289:     Returns
290:     -------
291:     y : A floating point representation of Not a Number.
292: 
293:     See Also
294:     --------
295:     isnan : Shows which elements are Not a Number.
296:     isfinite : Shows which elements are finite (not one of
297:                Not a Number, positive infinity and negative infinity)
298: 
299:     Notes
300:     -----
301:     Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
302:     (IEEE 754). This means that Not a Number is not equivalent to infinity.
303: 
304:     `NaN` and `NAN` are aliases of `nan`.
305: 
306:     Examples
307:     --------
308:     >>> np.nan
309:     nan
310:     >>> np.log(-1)
311:     nan
312:     >>> np.log([-1, 1, 2])
313:     array([        NaN,  0.        ,  0.69314718])
314: 
315:     ''')
316: 
317: add_newdoc('numpy', 'newaxis',
318:     '''
319:     A convenient alias for None, useful for indexing arrays.
320: 
321:     See Also
322:     --------
323:     `numpy.doc.indexing`
324: 
325:     Examples
326:     --------
327:     >>> newaxis is None
328:     True
329:     >>> x = np.arange(3)
330:     >>> x
331:     array([0, 1, 2])
332:     >>> x[:, newaxis]
333:     array([[0],
334:     [1],
335:     [2]])
336:     >>> x[:, newaxis, newaxis]
337:     array([[[0]],
338:     [[1]],
339:     [[2]]])
340:     >>> x[:, newaxis] * x
341:     array([[0, 0, 0],
342:     [0, 1, 2],
343:     [0, 2, 4]])
344: 
345:     Outer product, same as ``outer(x, y)``:
346: 
347:     >>> y = np.arange(3, 6)
348:     >>> x[:, newaxis] * y
349:     array([[ 0,  0,  0],
350:     [ 3,  4,  5],
351:     [ 6,  8, 10]])
352: 
353:     ``x[newaxis, :]`` is equivalent to ``x[newaxis]`` and ``x[None]``:
354: 
355:     >>> x[newaxis, :].shape
356:     (1, 3)
357:     >>> x[newaxis].shape
358:     (1, 3)
359:     >>> x[None].shape
360:     (1, 3)
361:     >>> x[:, newaxis].shape
362:     (3, 1)
363: 
364:     ''')
365: 
366: if __doc__:
367:     constants_str = []
368:     constants.sort()
369:     for name, doc in constants:
370:         s = textwrap.dedent(doc).replace("\n", "\n    ")
371: 
372:         # Replace sections by rubrics
373:         lines = s.split("\n")
374:         new_lines = []
375:         for line in lines:
376:             m = re.match(r'^(\s+)[-=]+\s*$', line)
377:             if m and new_lines:
378:                 prev = textwrap.dedent(new_lines.pop())
379:                 new_lines.append('%s.. rubric:: %s' % (m.group(1), prev))
380:                 new_lines.append('')
381:             else:
382:                 new_lines.append(line)
383:         s = "\n".join(new_lines)
384: 
385:         # Done.
386:         constants_str.append('''.. const:: %s\n    %s''' % (name, s))
387:     constants_str = "\n".join(constants_str)
388: 
389:     __doc__ = __doc__ % dict(constant_list=constants_str)
390:     del constants_str, name, doc
391:     del line, lines, new_lines, m, s, prev
392: 
393: del constants, add_newdoc
394: 

"""

# Import the stypy library necessary elements
from stypy.type_inference_programs.type_inference_programs_imports import *

# Create the module type store
module_type_store = Context(None, __file__)

# ################# Begin of the type inference program ##################

str_66422 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 9, (-1)), 'str', '\n=========\nConstants\n=========\n\nNumpy includes several constants:\n\n%(constant_list)s\n')
stypy.reporting.localization.Localization.set_current(stypy.reporting.localization.Localization(__file__, 15, 0))

# Multiple import statement. import textwrap (1/2) (line 15)
import textwrap

import_module(stypy.reporting.localization.Localization(__file__, 15, 0), 'textwrap', textwrap, module_type_store)
# Multiple import statement. import re (2/2) (line 15)
import re

import_module(stypy.reporting.localization.Localization(__file__, 15, 0), 're', re, module_type_store)


# Assigning a List to a Name (line 18):

# Obtaining an instance of the builtin type 'list' (line 18)
list_66423 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 18, 12), 'list')
# Adding type elements to the builtin type 'list' instance (line 18)

# Assigning a type to the variable 'constants' (line 18)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 18, 0), 'constants', list_66423)

@norecursion
def add_newdoc(localization, *varargs, **kwargs):
    global module_type_store
    # Assign values to the parameters with defaults
    defaults = []
    # Create a new context for function 'add_newdoc'
    module_type_store = module_type_store.open_function_context('add_newdoc', 19, 0, False)
    
    # Passed parameters checking function
    add_newdoc.stypy_localization = localization
    add_newdoc.stypy_type_of_self = None
    add_newdoc.stypy_type_store = module_type_store
    add_newdoc.stypy_function_name = 'add_newdoc'
    add_newdoc.stypy_param_names_list = ['module', 'name', 'doc']
    add_newdoc.stypy_varargs_param_name = None
    add_newdoc.stypy_kwargs_param_name = None
    add_newdoc.stypy_call_defaults = defaults
    add_newdoc.stypy_call_varargs = varargs
    add_newdoc.stypy_call_kwargs = kwargs
    arguments = process_argument_values(localization, None, module_type_store, 'add_newdoc', ['module', 'name', 'doc'], None, None, defaults, varargs, kwargs)

    if is_error_type(arguments):
        # Destroy the current context
        module_type_store = module_type_store.close_function_context()
        return arguments

    # Initialize method data
    init_call_information(module_type_store, 'add_newdoc', localization, ['module', 'name', 'doc'], arguments)
    
    # Default return type storage variable (SSA)
    # Assigning a type to the variable 'stypy_return_type'
    module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 0, 0), 'stypy_return_type', None)
    
    
    # ################# Begin of 'add_newdoc(...)' code ##################

    
    # Call to append(...): (line 20)
    # Processing the call arguments (line 20)
    
    # Obtaining an instance of the builtin type 'tuple' (line 20)
    tuple_66426 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 20, 22), 'tuple')
    # Adding type elements to the builtin type 'tuple' instance (line 20)
    # Adding element type (line 20)
    # Getting the type of 'name' (line 20)
    name_66427 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 20, 22), 'name', False)
    add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 20, 22), tuple_66426, name_66427)
    # Adding element type (line 20)
    # Getting the type of 'doc' (line 20)
    doc_66428 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 20, 28), 'doc', False)
    add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 20, 22), tuple_66426, doc_66428)
    
    # Processing the call keyword arguments (line 20)
    kwargs_66429 = {}
    # Getting the type of 'constants' (line 20)
    constants_66424 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 20, 4), 'constants', False)
    # Obtaining the member 'append' of a type (line 20)
    append_66425 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 20, 4), constants_66424, 'append')
    # Calling append(args, kwargs) (line 20)
    append_call_result_66430 = invoke(stypy.reporting.localization.Localization(__file__, 20, 4), append_66425, *[tuple_66426], **kwargs_66429)
    
    
    # ################# End of 'add_newdoc(...)' code ##################

    # Teardown call information
    teardown_call_information(localization, arguments)
    
    # Storing the return type of function 'add_newdoc' in the type store
    # Getting the type of 'stypy_return_type' (line 19)
    stypy_return_type_66431 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 19, 0), 'stypy_return_type')
    module_type_store.store_return_type_of_current_context(stypy_return_type_66431)
    
    # Destroy the current context
    module_type_store = module_type_store.close_function_context()
    
    # Return type of the function 'add_newdoc'
    return stypy_return_type_66431

# Assigning a type to the variable 'add_newdoc' (line 19)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 19, 0), 'add_newdoc', add_newdoc)

# Call to add_newdoc(...): (line 22)
# Processing the call arguments (line 22)
str_66433 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 22, 11), 'str', 'numpy')
str_66434 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 22, 20), 'str', 'Inf')
str_66435 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 33, (-1)), 'str', '\n    IEEE 754 floating point representation of (positive) infinity.\n\n    Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n    `inf`. For more details, see `inf`.\n\n    See Also\n    --------\n    inf\n\n    ')
# Processing the call keyword arguments (line 22)
kwargs_66436 = {}
# Getting the type of 'add_newdoc' (line 22)
add_newdoc_66432 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 22, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 22)
add_newdoc_call_result_66437 = invoke(stypy.reporting.localization.Localization(__file__, 22, 0), add_newdoc_66432, *[str_66433, str_66434, str_66435], **kwargs_66436)


# Call to add_newdoc(...): (line 35)
# Processing the call arguments (line 35)
str_66439 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 35, 11), 'str', 'numpy')
str_66440 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 35, 20), 'str', 'Infinity')
str_66441 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 46, (-1)), 'str', '\n    IEEE 754 floating point representation of (positive) infinity.\n\n    Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n    `inf`. For more details, see `inf`.\n\n    See Also\n    --------\n    inf\n\n    ')
# Processing the call keyword arguments (line 35)
kwargs_66442 = {}
# Getting the type of 'add_newdoc' (line 35)
add_newdoc_66438 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 35, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 35)
add_newdoc_call_result_66443 = invoke(stypy.reporting.localization.Localization(__file__, 35, 0), add_newdoc_66438, *[str_66439, str_66440, str_66441], **kwargs_66442)


# Call to add_newdoc(...): (line 48)
# Processing the call arguments (line 48)
str_66445 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 48, 11), 'str', 'numpy')
str_66446 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 48, 20), 'str', 'NAN')
str_66447 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 59, (-1)), 'str', '\n    IEEE 754 floating point representation of Not a Number (NaN).\n\n    `NaN` and `NAN` are equivalent definitions of `nan`. Please use\n    `nan` instead of `NAN`.\n\n    See Also\n    --------\n    nan\n\n    ')
# Processing the call keyword arguments (line 48)
kwargs_66448 = {}
# Getting the type of 'add_newdoc' (line 48)
add_newdoc_66444 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 48, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 48)
add_newdoc_call_result_66449 = invoke(stypy.reporting.localization.Localization(__file__, 48, 0), add_newdoc_66444, *[str_66445, str_66446, str_66447], **kwargs_66448)


# Call to add_newdoc(...): (line 61)
# Processing the call arguments (line 61)
str_66451 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 61, 11), 'str', 'numpy')
str_66452 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 61, 20), 'str', 'NINF')
str_66453 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 97, (-1)), 'str', '\n    IEEE 754 floating point representation of negative infinity.\n\n    Returns\n    -------\n    y : float\n        A floating point representation of negative infinity.\n\n    See Also\n    --------\n    isinf : Shows which elements are positive or negative infinity\n\n    isposinf : Shows which elements are positive infinity\n\n    isneginf : Shows which elements are negative infinity\n\n    isnan : Shows which elements are Not a Number\n\n    isfinite : Shows which elements are finite (not one of Not a Number,\n    positive infinity and negative infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Also that positive infinity is not equivalent to negative infinity. But\n    infinity is equivalent to positive infinity.\n\n    Examples\n    --------\n    >>> np.NINF\n    -inf\n    >>> np.log(0)\n    -inf\n\n    ')
# Processing the call keyword arguments (line 61)
kwargs_66454 = {}
# Getting the type of 'add_newdoc' (line 61)
add_newdoc_66450 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 61, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 61)
add_newdoc_call_result_66455 = invoke(stypy.reporting.localization.Localization(__file__, 61, 0), add_newdoc_66450, *[str_66451, str_66452, str_66453], **kwargs_66454)


# Call to add_newdoc(...): (line 99)
# Processing the call arguments (line 99)
str_66457 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 99, 11), 'str', 'numpy')
str_66458 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 99, 20), 'str', 'NZERO')
str_66459 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 142, (-1)), 'str', '\n    IEEE 754 floating point representation of negative zero.\n\n    Returns\n    -------\n    y : float\n        A floating point representation of negative zero.\n\n    See Also\n    --------\n    PZERO : Defines positive zero.\n\n    isinf : Shows which elements are positive or negative infinity.\n\n    isposinf : Shows which elements are positive infinity.\n\n    isneginf : Shows which elements are negative infinity.\n\n    isnan : Shows which elements are Not a Number.\n\n    isfinite : Shows which elements are finite - not one of\n               Not a Number, positive infinity and negative infinity.\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). Negative zero is considered to be a finite number.\n\n    Examples\n    --------\n    >>> np.NZERO\n    -0.0\n    >>> np.PZERO\n    0.0\n\n    >>> np.isfinite([np.NZERO])\n    array([ True], dtype=bool)\n    >>> np.isnan([np.NZERO])\n    array([False], dtype=bool)\n    >>> np.isinf([np.NZERO])\n    array([False], dtype=bool)\n\n    ')
# Processing the call keyword arguments (line 99)
kwargs_66460 = {}
# Getting the type of 'add_newdoc' (line 99)
add_newdoc_66456 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 99, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 99)
add_newdoc_call_result_66461 = invoke(stypy.reporting.localization.Localization(__file__, 99, 0), add_newdoc_66456, *[str_66457, str_66458, str_66459], **kwargs_66460)


# Call to add_newdoc(...): (line 144)
# Processing the call arguments (line 144)
str_66463 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 144, 11), 'str', 'numpy')
str_66464 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 144, 20), 'str', 'NaN')
str_66465 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 155, (-1)), 'str', '\n    IEEE 754 floating point representation of Not a Number (NaN).\n\n    `NaN` and `NAN` are equivalent definitions of `nan`. Please use\n    `nan` instead of `NaN`.\n\n    See Also\n    --------\n    nan\n\n    ')
# Processing the call keyword arguments (line 144)
kwargs_66466 = {}
# Getting the type of 'add_newdoc' (line 144)
add_newdoc_66462 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 144, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 144)
add_newdoc_call_result_66467 = invoke(stypy.reporting.localization.Localization(__file__, 144, 0), add_newdoc_66462, *[str_66463, str_66464, str_66465], **kwargs_66466)


# Call to add_newdoc(...): (line 157)
# Processing the call arguments (line 157)
str_66469 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 157, 11), 'str', 'numpy')
str_66470 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 157, 20), 'str', 'PINF')
str_66471 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 168, (-1)), 'str', '\n    IEEE 754 floating point representation of (positive) infinity.\n\n    Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n    `inf`. For more details, see `inf`.\n\n    See Also\n    --------\n    inf\n\n    ')
# Processing the call keyword arguments (line 157)
kwargs_66472 = {}
# Getting the type of 'add_newdoc' (line 157)
add_newdoc_66468 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 157, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 157)
add_newdoc_call_result_66473 = invoke(stypy.reporting.localization.Localization(__file__, 157, 0), add_newdoc_66468, *[str_66469, str_66470, str_66471], **kwargs_66472)


# Call to add_newdoc(...): (line 170)
# Processing the call arguments (line 170)
str_66475 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 170, 11), 'str', 'numpy')
str_66476 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 170, 20), 'str', 'PZERO')
str_66477 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 213, (-1)), 'str', '\n    IEEE 754 floating point representation of positive zero.\n\n    Returns\n    -------\n    y : float\n        A floating point representation of positive zero.\n\n    See Also\n    --------\n    NZERO : Defines negative zero.\n\n    isinf : Shows which elements are positive or negative infinity.\n\n    isposinf : Shows which elements are positive infinity.\n\n    isneginf : Shows which elements are negative infinity.\n\n    isnan : Shows which elements are Not a Number.\n\n    isfinite : Shows which elements are finite - not one of\n               Not a Number, positive infinity and negative infinity.\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). Positive zero is considered to be a finite number.\n\n    Examples\n    --------\n    >>> np.PZERO\n    0.0\n    >>> np.NZERO\n    -0.0\n\n    >>> np.isfinite([np.PZERO])\n    array([ True], dtype=bool)\n    >>> np.isnan([np.PZERO])\n    array([False], dtype=bool)\n    >>> np.isinf([np.PZERO])\n    array([False], dtype=bool)\n\n    ')
# Processing the call keyword arguments (line 170)
kwargs_66478 = {}
# Getting the type of 'add_newdoc' (line 170)
add_newdoc_66474 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 170, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 170)
add_newdoc_call_result_66479 = invoke(stypy.reporting.localization.Localization(__file__, 170, 0), add_newdoc_66474, *[str_66475, str_66476, str_66477], **kwargs_66478)


# Call to add_newdoc(...): (line 215)
# Processing the call arguments (line 215)
str_66481 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 215, 11), 'str', 'numpy')
str_66482 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 215, 20), 'str', 'e')
str_66483 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 230, (-1)), 'str', "\n    Euler's constant, base of natural logarithms, Napier's constant.\n\n    ``e = 2.71828182845904523536028747135266249775724709369995...``\n\n    See Also\n    --------\n    exp : Exponential function\n    log : Natural logarithm\n\n    References\n    ----------\n    .. [1] http://en.wikipedia.org/wiki/Napier_constant\n\n    ")
# Processing the call keyword arguments (line 215)
kwargs_66484 = {}
# Getting the type of 'add_newdoc' (line 215)
add_newdoc_66480 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 215, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 215)
add_newdoc_call_result_66485 = invoke(stypy.reporting.localization.Localization(__file__, 215, 0), add_newdoc_66480, *[str_66481, str_66482, str_66483], **kwargs_66484)


# Call to add_newdoc(...): (line 232)
# Processing the call arguments (line 232)
str_66487 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 232, 11), 'str', 'numpy')
str_66488 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 232, 20), 'str', 'inf')
str_66489 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 270, (-1)), 'str', '\n    IEEE 754 floating point representation of (positive) infinity.\n\n    Returns\n    -------\n    y : float\n        A floating point representation of positive infinity.\n\n    See Also\n    --------\n    isinf : Shows which elements are positive or negative infinity\n\n    isposinf : Shows which elements are positive infinity\n\n    isneginf : Shows which elements are negative infinity\n\n    isnan : Shows which elements are Not a Number\n\n    isfinite : Shows which elements are finite (not one of Not a Number,\n    positive infinity and negative infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n    Also that positive infinity is not equivalent to negative infinity. But\n    infinity is equivalent to positive infinity.\n\n    `Inf`, `Infinity`, `PINF` and `infty` are aliases for `inf`.\n\n    Examples\n    --------\n    >>> np.inf\n    inf\n    >>> np.array([1]) / 0.\n    array([ Inf])\n\n    ')
# Processing the call keyword arguments (line 232)
kwargs_66490 = {}
# Getting the type of 'add_newdoc' (line 232)
add_newdoc_66486 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 232, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 232)
add_newdoc_call_result_66491 = invoke(stypy.reporting.localization.Localization(__file__, 232, 0), add_newdoc_66486, *[str_66487, str_66488, str_66489], **kwargs_66490)


# Call to add_newdoc(...): (line 272)
# Processing the call arguments (line 272)
str_66493 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 272, 11), 'str', 'numpy')
str_66494 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 272, 20), 'str', 'infty')
str_66495 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 283, (-1)), 'str', '\n    IEEE 754 floating point representation of (positive) infinity.\n\n    Use `inf` because `Inf`, `Infinity`, `PINF` and `infty` are aliases for\n    `inf`. For more details, see `inf`.\n\n    See Also\n    --------\n    inf\n\n    ')
# Processing the call keyword arguments (line 272)
kwargs_66496 = {}
# Getting the type of 'add_newdoc' (line 272)
add_newdoc_66492 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 272, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 272)
add_newdoc_call_result_66497 = invoke(stypy.reporting.localization.Localization(__file__, 272, 0), add_newdoc_66492, *[str_66493, str_66494, str_66495], **kwargs_66496)


# Call to add_newdoc(...): (line 285)
# Processing the call arguments (line 285)
str_66499 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 285, 11), 'str', 'numpy')
str_66500 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 285, 20), 'str', 'nan')
str_66501 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 315, (-1)), 'str', '\n    IEEE 754 floating point representation of Not a Number (NaN).\n\n    Returns\n    -------\n    y : A floating point representation of Not a Number.\n\n    See Also\n    --------\n    isnan : Shows which elements are Not a Number.\n    isfinite : Shows which elements are finite (not one of\n               Not a Number, positive infinity and negative infinity)\n\n    Notes\n    -----\n    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n    (IEEE 754). This means that Not a Number is not equivalent to infinity.\n\n    `NaN` and `NAN` are aliases of `nan`.\n\n    Examples\n    --------\n    >>> np.nan\n    nan\n    >>> np.log(-1)\n    nan\n    >>> np.log([-1, 1, 2])\n    array([        NaN,  0.        ,  0.69314718])\n\n    ')
# Processing the call keyword arguments (line 285)
kwargs_66502 = {}
# Getting the type of 'add_newdoc' (line 285)
add_newdoc_66498 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 285, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 285)
add_newdoc_call_result_66503 = invoke(stypy.reporting.localization.Localization(__file__, 285, 0), add_newdoc_66498, *[str_66499, str_66500, str_66501], **kwargs_66502)


# Call to add_newdoc(...): (line 317)
# Processing the call arguments (line 317)
str_66505 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 317, 11), 'str', 'numpy')
str_66506 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 317, 20), 'str', 'newaxis')
str_66507 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 364, (-1)), 'str', '\n    A convenient alias for None, useful for indexing arrays.\n\n    See Also\n    --------\n    `numpy.doc.indexing`\n\n    Examples\n    --------\n    >>> newaxis is None\n    True\n    >>> x = np.arange(3)\n    >>> x\n    array([0, 1, 2])\n    >>> x[:, newaxis]\n    array([[0],\n    [1],\n    [2]])\n    >>> x[:, newaxis, newaxis]\n    array([[[0]],\n    [[1]],\n    [[2]]])\n    >>> x[:, newaxis] * x\n    array([[0, 0, 0],\n    [0, 1, 2],\n    [0, 2, 4]])\n\n    Outer product, same as ``outer(x, y)``:\n\n    >>> y = np.arange(3, 6)\n    >>> x[:, newaxis] * y\n    array([[ 0,  0,  0],\n    [ 3,  4,  5],\n    [ 6,  8, 10]])\n\n    ``x[newaxis, :]`` is equivalent to ``x[newaxis]`` and ``x[None]``:\n\n    >>> x[newaxis, :].shape\n    (1, 3)\n    >>> x[newaxis].shape\n    (1, 3)\n    >>> x[None].shape\n    (1, 3)\n    >>> x[:, newaxis].shape\n    (3, 1)\n\n    ')
# Processing the call keyword arguments (line 317)
kwargs_66508 = {}
# Getting the type of 'add_newdoc' (line 317)
add_newdoc_66504 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 317, 0), 'add_newdoc', False)
# Calling add_newdoc(args, kwargs) (line 317)
add_newdoc_call_result_66509 = invoke(stypy.reporting.localization.Localization(__file__, 317, 0), add_newdoc_66504, *[str_66505, str_66506, str_66507], **kwargs_66508)


# Getting the type of '__doc__' (line 366)
doc___66510 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 366, 3), '__doc__')
# Testing the type of an if condition (line 366)
if_condition_66511 = is_suitable_condition(stypy.reporting.localization.Localization(__file__, 366, 0), doc___66510)
# Assigning a type to the variable 'if_condition_66511' (line 366)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 366, 0), 'if_condition_66511', if_condition_66511)
# SSA begins for if statement (line 366)
module_type_store = SSAContext.create_ssa_context(module_type_store, 'if')

# Assigning a List to a Name (line 367):

# Obtaining an instance of the builtin type 'list' (line 367)
list_66512 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 367, 20), 'list')
# Adding type elements to the builtin type 'list' instance (line 367)

# Assigning a type to the variable 'constants_str' (line 367)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 367, 4), 'constants_str', list_66512)

# Call to sort(...): (line 368)
# Processing the call keyword arguments (line 368)
kwargs_66515 = {}
# Getting the type of 'constants' (line 368)
constants_66513 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 368, 4), 'constants', False)
# Obtaining the member 'sort' of a type (line 368)
sort_66514 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 368, 4), constants_66513, 'sort')
# Calling sort(args, kwargs) (line 368)
sort_call_result_66516 = invoke(stypy.reporting.localization.Localization(__file__, 368, 4), sort_66514, *[], **kwargs_66515)


# Getting the type of 'constants' (line 369)
constants_66517 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 369, 21), 'constants')
# Testing the type of a for loop iterable (line 369)
is_suitable_for_loop_condition(stypy.reporting.localization.Localization(__file__, 369, 4), constants_66517)
# Getting the type of the for loop variable (line 369)
for_loop_var_66518 = get_type_of_for_loop_variable(stypy.reporting.localization.Localization(__file__, 369, 4), constants_66517)
# Assigning a type to the variable 'name' (line 369)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 369, 4), 'name', get_contained_elements_type(stypy.reporting.localization.Localization(__file__, 369, 4), for_loop_var_66518))
# Assigning a type to the variable 'doc' (line 369)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 369, 4), 'doc', get_contained_elements_type(stypy.reporting.localization.Localization(__file__, 369, 4), for_loop_var_66518))
# SSA begins for a for statement (line 369)
module_type_store = SSAContext.create_ssa_context(module_type_store, 'for loop')

# Assigning a Call to a Name (line 370):

# Call to replace(...): (line 370)
# Processing the call arguments (line 370)
str_66525 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 370, 41), 'str', '\n')
str_66526 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 370, 47), 'str', '\n    ')
# Processing the call keyword arguments (line 370)
kwargs_66527 = {}

# Call to dedent(...): (line 370)
# Processing the call arguments (line 370)
# Getting the type of 'doc' (line 370)
doc_66521 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 370, 28), 'doc', False)
# Processing the call keyword arguments (line 370)
kwargs_66522 = {}
# Getting the type of 'textwrap' (line 370)
textwrap_66519 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 370, 12), 'textwrap', False)
# Obtaining the member 'dedent' of a type (line 370)
dedent_66520 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 370, 12), textwrap_66519, 'dedent')
# Calling dedent(args, kwargs) (line 370)
dedent_call_result_66523 = invoke(stypy.reporting.localization.Localization(__file__, 370, 12), dedent_66520, *[doc_66521], **kwargs_66522)

# Obtaining the member 'replace' of a type (line 370)
replace_66524 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 370, 12), dedent_call_result_66523, 'replace')
# Calling replace(args, kwargs) (line 370)
replace_call_result_66528 = invoke(stypy.reporting.localization.Localization(__file__, 370, 12), replace_66524, *[str_66525, str_66526], **kwargs_66527)

# Assigning a type to the variable 's' (line 370)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 370, 8), 's', replace_call_result_66528)

# Assigning a Call to a Name (line 373):

# Call to split(...): (line 373)
# Processing the call arguments (line 373)
str_66531 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 373, 24), 'str', '\n')
# Processing the call keyword arguments (line 373)
kwargs_66532 = {}
# Getting the type of 's' (line 373)
s_66529 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 373, 16), 's', False)
# Obtaining the member 'split' of a type (line 373)
split_66530 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 373, 16), s_66529, 'split')
# Calling split(args, kwargs) (line 373)
split_call_result_66533 = invoke(stypy.reporting.localization.Localization(__file__, 373, 16), split_66530, *[str_66531], **kwargs_66532)

# Assigning a type to the variable 'lines' (line 373)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 373, 8), 'lines', split_call_result_66533)

# Assigning a List to a Name (line 374):

# Obtaining an instance of the builtin type 'list' (line 374)
list_66534 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 374, 20), 'list')
# Adding type elements to the builtin type 'list' instance (line 374)

# Assigning a type to the variable 'new_lines' (line 374)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 374, 8), 'new_lines', list_66534)

# Getting the type of 'lines' (line 375)
lines_66535 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 375, 20), 'lines')
# Testing the type of a for loop iterable (line 375)
is_suitable_for_loop_condition(stypy.reporting.localization.Localization(__file__, 375, 8), lines_66535)
# Getting the type of the for loop variable (line 375)
for_loop_var_66536 = get_type_of_for_loop_variable(stypy.reporting.localization.Localization(__file__, 375, 8), lines_66535)
# Assigning a type to the variable 'line' (line 375)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 375, 8), 'line', for_loop_var_66536)
# SSA begins for a for statement (line 375)
module_type_store = SSAContext.create_ssa_context(module_type_store, 'for loop')

# Assigning a Call to a Name (line 376):

# Call to match(...): (line 376)
# Processing the call arguments (line 376)
str_66539 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 376, 25), 'str', '^(\\s+)[-=]+\\s*$')
# Getting the type of 'line' (line 376)
line_66540 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 376, 45), 'line', False)
# Processing the call keyword arguments (line 376)
kwargs_66541 = {}
# Getting the type of 're' (line 376)
re_66537 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 376, 16), 're', False)
# Obtaining the member 'match' of a type (line 376)
match_66538 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 376, 16), re_66537, 'match')
# Calling match(args, kwargs) (line 376)
match_call_result_66542 = invoke(stypy.reporting.localization.Localization(__file__, 376, 16), match_66538, *[str_66539, line_66540], **kwargs_66541)

# Assigning a type to the variable 'm' (line 376)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 376, 12), 'm', match_call_result_66542)


# Evaluating a boolean operation
# Getting the type of 'm' (line 377)
m_66543 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 377, 15), 'm')
# Getting the type of 'new_lines' (line 377)
new_lines_66544 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 377, 21), 'new_lines')
# Applying the binary operator 'and' (line 377)
result_and_keyword_66545 = python_operator(stypy.reporting.localization.Localization(__file__, 377, 15), 'and', m_66543, new_lines_66544)

# Testing the type of an if condition (line 377)
if_condition_66546 = is_suitable_condition(stypy.reporting.localization.Localization(__file__, 377, 12), result_and_keyword_66545)
# Assigning a type to the variable 'if_condition_66546' (line 377)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 377, 12), 'if_condition_66546', if_condition_66546)
# SSA begins for if statement (line 377)
module_type_store = SSAContext.create_ssa_context(module_type_store, 'if')

# Assigning a Call to a Name (line 378):

# Call to dedent(...): (line 378)
# Processing the call arguments (line 378)

# Call to pop(...): (line 378)
# Processing the call keyword arguments (line 378)
kwargs_66551 = {}
# Getting the type of 'new_lines' (line 378)
new_lines_66549 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 378, 39), 'new_lines', False)
# Obtaining the member 'pop' of a type (line 378)
pop_66550 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 378, 39), new_lines_66549, 'pop')
# Calling pop(args, kwargs) (line 378)
pop_call_result_66552 = invoke(stypy.reporting.localization.Localization(__file__, 378, 39), pop_66550, *[], **kwargs_66551)

# Processing the call keyword arguments (line 378)
kwargs_66553 = {}
# Getting the type of 'textwrap' (line 378)
textwrap_66547 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 378, 23), 'textwrap', False)
# Obtaining the member 'dedent' of a type (line 378)
dedent_66548 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 378, 23), textwrap_66547, 'dedent')
# Calling dedent(args, kwargs) (line 378)
dedent_call_result_66554 = invoke(stypy.reporting.localization.Localization(__file__, 378, 23), dedent_66548, *[pop_call_result_66552], **kwargs_66553)

# Assigning a type to the variable 'prev' (line 378)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 378, 16), 'prev', dedent_call_result_66554)

# Call to append(...): (line 379)
# Processing the call arguments (line 379)
str_66557 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 379, 33), 'str', '%s.. rubric:: %s')

# Obtaining an instance of the builtin type 'tuple' (line 379)
tuple_66558 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 379, 55), 'tuple')
# Adding type elements to the builtin type 'tuple' instance (line 379)
# Adding element type (line 379)

# Call to group(...): (line 379)
# Processing the call arguments (line 379)
int_66561 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 379, 63), 'int')
# Processing the call keyword arguments (line 379)
kwargs_66562 = {}
# Getting the type of 'm' (line 379)
m_66559 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 379, 55), 'm', False)
# Obtaining the member 'group' of a type (line 379)
group_66560 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 379, 55), m_66559, 'group')
# Calling group(args, kwargs) (line 379)
group_call_result_66563 = invoke(stypy.reporting.localization.Localization(__file__, 379, 55), group_66560, *[int_66561], **kwargs_66562)

add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 379, 55), tuple_66558, group_call_result_66563)
# Adding element type (line 379)
# Getting the type of 'prev' (line 379)
prev_66564 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 379, 67), 'prev', False)
add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 379, 55), tuple_66558, prev_66564)

# Applying the binary operator '%' (line 379)
result_mod_66565 = python_operator(stypy.reporting.localization.Localization(__file__, 379, 33), '%', str_66557, tuple_66558)

# Processing the call keyword arguments (line 379)
kwargs_66566 = {}
# Getting the type of 'new_lines' (line 379)
new_lines_66555 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 379, 16), 'new_lines', False)
# Obtaining the member 'append' of a type (line 379)
append_66556 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 379, 16), new_lines_66555, 'append')
# Calling append(args, kwargs) (line 379)
append_call_result_66567 = invoke(stypy.reporting.localization.Localization(__file__, 379, 16), append_66556, *[result_mod_66565], **kwargs_66566)


# Call to append(...): (line 380)
# Processing the call arguments (line 380)
str_66570 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 380, 33), 'str', '')
# Processing the call keyword arguments (line 380)
kwargs_66571 = {}
# Getting the type of 'new_lines' (line 380)
new_lines_66568 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 380, 16), 'new_lines', False)
# Obtaining the member 'append' of a type (line 380)
append_66569 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 380, 16), new_lines_66568, 'append')
# Calling append(args, kwargs) (line 380)
append_call_result_66572 = invoke(stypy.reporting.localization.Localization(__file__, 380, 16), append_66569, *[str_66570], **kwargs_66571)

# SSA branch for the else part of an if statement (line 377)
module_type_store.open_ssa_branch('else')

# Call to append(...): (line 382)
# Processing the call arguments (line 382)
# Getting the type of 'line' (line 382)
line_66575 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 382, 33), 'line', False)
# Processing the call keyword arguments (line 382)
kwargs_66576 = {}
# Getting the type of 'new_lines' (line 382)
new_lines_66573 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 382, 16), 'new_lines', False)
# Obtaining the member 'append' of a type (line 382)
append_66574 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 382, 16), new_lines_66573, 'append')
# Calling append(args, kwargs) (line 382)
append_call_result_66577 = invoke(stypy.reporting.localization.Localization(__file__, 382, 16), append_66574, *[line_66575], **kwargs_66576)

# SSA join for if statement (line 377)
module_type_store = module_type_store.join_ssa_context()

# SSA join for a for statement
module_type_store = module_type_store.join_ssa_context()


# Assigning a Call to a Name (line 383):

# Call to join(...): (line 383)
# Processing the call arguments (line 383)
# Getting the type of 'new_lines' (line 383)
new_lines_66580 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 383, 22), 'new_lines', False)
# Processing the call keyword arguments (line 383)
kwargs_66581 = {}
str_66578 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 383, 12), 'str', '\n')
# Obtaining the member 'join' of a type (line 383)
join_66579 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 383, 12), str_66578, 'join')
# Calling join(args, kwargs) (line 383)
join_call_result_66582 = invoke(stypy.reporting.localization.Localization(__file__, 383, 12), join_66579, *[new_lines_66580], **kwargs_66581)

# Assigning a type to the variable 's' (line 383)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 383, 8), 's', join_call_result_66582)

# Call to append(...): (line 386)
# Processing the call arguments (line 386)
str_66585 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 386, 29), 'str', '.. const:: %s\n    %s')

# Obtaining an instance of the builtin type 'tuple' (line 386)
tuple_66586 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 386, 60), 'tuple')
# Adding type elements to the builtin type 'tuple' instance (line 386)
# Adding element type (line 386)
# Getting the type of 'name' (line 386)
name_66587 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 386, 60), 'name', False)
add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 386, 60), tuple_66586, name_66587)
# Adding element type (line 386)
# Getting the type of 's' (line 386)
s_66588 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 386, 66), 's', False)
add_contained_elements_type(stypy.reporting.localization.Localization(__file__, 386, 60), tuple_66586, s_66588)

# Applying the binary operator '%' (line 386)
result_mod_66589 = python_operator(stypy.reporting.localization.Localization(__file__, 386, 29), '%', str_66585, tuple_66586)

# Processing the call keyword arguments (line 386)
kwargs_66590 = {}
# Getting the type of 'constants_str' (line 386)
constants_str_66583 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 386, 8), 'constants_str', False)
# Obtaining the member 'append' of a type (line 386)
append_66584 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 386, 8), constants_str_66583, 'append')
# Calling append(args, kwargs) (line 386)
append_call_result_66591 = invoke(stypy.reporting.localization.Localization(__file__, 386, 8), append_66584, *[result_mod_66589], **kwargs_66590)

# SSA join for a for statement
module_type_store = module_type_store.join_ssa_context()


# Assigning a Call to a Name (line 387):

# Call to join(...): (line 387)
# Processing the call arguments (line 387)
# Getting the type of 'constants_str' (line 387)
constants_str_66594 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 387, 30), 'constants_str', False)
# Processing the call keyword arguments (line 387)
kwargs_66595 = {}
str_66592 = get_builtin_python_type_instance(stypy.reporting.localization.Localization(__file__, 387, 20), 'str', '\n')
# Obtaining the member 'join' of a type (line 387)
join_66593 = module_type_store.get_type_of_member(stypy.reporting.localization.Localization(__file__, 387, 20), str_66592, 'join')
# Calling join(args, kwargs) (line 387)
join_call_result_66596 = invoke(stypy.reporting.localization.Localization(__file__, 387, 20), join_66593, *[constants_str_66594], **kwargs_66595)

# Assigning a type to the variable 'constants_str' (line 387)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 387, 4), 'constants_str', join_call_result_66596)

# Assigning a BinOp to a Name (line 389):
# Getting the type of '__doc__' (line 389)
doc___66597 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 389, 14), '__doc__')

# Call to dict(...): (line 389)
# Processing the call keyword arguments (line 389)
# Getting the type of 'constants_str' (line 389)
constants_str_66599 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 389, 43), 'constants_str', False)
keyword_66600 = constants_str_66599
kwargs_66601 = {'constant_list': keyword_66600}
# Getting the type of 'dict' (line 389)
dict_66598 = module_type_store.get_type_of(stypy.reporting.localization.Localization(__file__, 389, 24), 'dict', False)
# Calling dict(args, kwargs) (line 389)
dict_call_result_66602 = invoke(stypy.reporting.localization.Localization(__file__, 389, 24), dict_66598, *[], **kwargs_66601)

# Applying the binary operator '%' (line 389)
result_mod_66603 = python_operator(stypy.reporting.localization.Localization(__file__, 389, 14), '%', doc___66597, dict_call_result_66602)

# Assigning a type to the variable '__doc__' (line 389)
module_type_store.set_type_of(stypy.reporting.localization.Localization(__file__, 389, 4), '__doc__', result_mod_66603)
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 390, 4), module_type_store, 'constants_str')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 390, 4), module_type_store, 'name')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 390, 4), module_type_store, 'doc')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 'line')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 'lines')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 'new_lines')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 'm')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 's')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 391, 4), module_type_store, 'prev')
# SSA join for if statement (line 366)
module_type_store = module_type_store.join_ssa_context()

# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 393, 0), module_type_store, 'constants')
# Deleting a member
module_type_store.del_member(stypy.reporting.localization.Localization(__file__, 393, 0), module_type_store, 'add_newdoc')

# ################# End of the type inference program ##################

module_errors = stypy.errors.type_error.StypyTypeError.get_error_msgs()
module_warnings = stypy.errors.type_warning.TypeWarning.get_warning_msgs()
