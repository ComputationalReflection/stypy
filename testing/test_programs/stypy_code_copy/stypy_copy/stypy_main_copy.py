import sys
import time
import imp
import ast

from visitor_copy.type_inference_copy import type_inference_visitor_copy
from visitor_copy.python_src_generation_copy.python_src_generator_visitor_copy import PythonSrcGeneratorVisitor
from visitor_copy.python_type_data_autogeneration_copy.python_type_data_autogeneration_visitor_copy import *
from visitor_copy.type_inference_copy.visitor_utils_copy.stypy_functions_copy import default_module_type_store_var_name, \
      default_type_error_var_name, default_type_warning_var_name
from visitor_copy.python_src_print_copy.python_src_print_visitor_copy import dump_ast
from stypy_parameters_copy import *
from visitor_copy.type_inference_copy.desugaring_copy import multiple_assignments_visitor_copy
from visitor_copy.type_inference_copy.desugaring_copy import class_attributes_visitor_copy
from visitor_copy.type_inference_copy.desugaring_copy import class__init__visitor_copy
from visitor_copy.type_annotation_copy.type_annotation_visitor_copy import TypeAnnotationVisitor
import type_store_copy
from type_store_copy import typestore_copy
from python_lib_copy.python_types_copy import type_inference_copy
from log_copy import logging_console_copy
from code_generation_copy.source_code_writer_copy import write_python_source_code


"""
Assigning log functions
"""
info = logging_console_copy.info
ok = logging_console_copy.ok
error = logging_console_copy.error
warning = logging_console_copy.warning

"Null log functions when log is disabled"


def f():
    pass


reset_logs = f


def void_print_func(*args):
    pass


class Stypy:
    """
    Main class for the stypy type-inference Python system. It controls all the interaction with Python source code files
    and stypy runtime. From a Python source file it:
    - Parses the file and generates an equivalent type-inference program. This program can be executed to tell the
    original program type errors
    - Optionally generates a type annotated Python source file identical to the original one but with types assigned
    to all its variables. It is the same functionality that stypy provides, but written into suitable places of a copy
    of the original file instead of reporting types and type errors via console. It is helpful for debuggin purposes
    and in the future it can be adapted to follow PEP 0484 (Type hints) https://www.python.org/dev/peps/pep-0484/
    - Optionally generates a version of the original program that calculates a table of variables and its runtime types.
    It does not work on 100% of the cases, its implementation is rather basic and may fail with some program constructs,
    but it help to generate tables of types that later on can be used to unit test generated type inference programs.
    """

    # ##################################### PRIVATE METHODS ######################################

    def __read_new_ast_from_file(self):
        """
        Reads the AST of the source Python file
        :return:
        """
        return ast.parse(self.original_program_src)

    def __get_original_source_file_ast(self):
        """
        Returns the AST of the source Python file
        :return:
        """
        return self.original_ast_tree

    @staticmethod
    def __run_program(file_path):
        """
        Runs a Python program importing its source code and providing fresh locals() and globals() environments. It is
        used to execute the various Python programs that stypy generates if needed.
        :param file_path:
        :return:
        """
        my_globals = globals()
        my_globals["__file__"] = file_path

        my_locals = dict()

        dirname = os.path.dirname(file_path)
        source_file = file_path.split('/')[-1][0:-3]

        sys.path.append(dirname)
        __import__(source_file, my_globals, my_locals)

    def __run_type_inference_program(self, file_path):
        """
        Runs a type inference program generated by stypy by importing it. It provides a fresh globals environment
        with initialized __file__ and __name__ environment variables, an empty locals() environment and time-measuring
        instrumentation. At the end of the execution, it extracts the generated type store, the type errors and the
        type warnings that have been detected.
        :param file_path: Program to run
        :return:
        """
        my_globals = globals()
        my_globals["__file__"] = file_path
        my_globals['__name__'] = '__main__'

        my_locals = dict()

        #dirname = os.path.dirname(file_path)
        source_file = file_path.split('/')[-1][0:-3]
        #
        # #sys.path.append(dirname)
        # sys.path = [dirname] + sys.path
        # self.tinit = time.time()
        # module = __import__(source_file, my_globals, my_locals)
        # self.tend = time.time()
        # sys.path.remove(dirname)
        module = imp.load_source(source_file, file_path)
        try:
            # After running the program, extract type inference data
            self.analyzed_program_type_store = getattr(module, default_module_type_store_var_name)
            self.analyzed_program_errors = getattr(module, default_type_error_var_name)
            self.analyzed_program_warnings = getattr(module, default_type_warning_var_name)
        except:
            self.analyzed_program_type_store = None
            self.analyzed_program_errors = []
            self.analyzed_program_warnings = []

    @staticmethod
    def __is_file_suitable_for_autocalculate_types(file_path):
        """
        Determines if a source file is suitable to generate a derived runtime type calculation program. Negative
        tests (those that fail at runtime) are not suitable for it because they cannot be fully executed to calculate
        the runtime type of its variables. Negative test program name begins with "error_" by convention.
        :param file_path: File to test
        :return:
        """
        return "error_" not in file_path

    @staticmethod
    def __configure_stypy_output(verbose):
        """
        Configures whether output are displayed on console or are not displayed
        :param verbose:
        :return:
        """
        global info
        global ok
        global error

        if verbose:
            info = sys.stdout.write
            ok = sys.stdout.write
            error = sys.stderr.write
        else:
            info = void_print_func
            ok = void_print_func
            error = void_print_func

    ###################################### PUBLIC METHODS ######################################

    def create_instance(self, source_file_path):
        """
        Creates a new instance of the Stypy class using the values of the current stypy instance regarding Python
        interpreter, output verbosity and optional file generation. Its purpose is to "spawn" a new Stypy object
        for a different source file with the same configuration quickly, in order to parse Python source modules
        that are loaded by the main parsed program
        :param source_file_path:
        :return:
        """
        return Stypy(source_file_path, self.python_exe, self.verbose, self.generate_type_data_file)

    def __init__(self, source_file_path, python_exe=PYTHON_EXE, verbose=False,
                 generate_type_data_file=False, generate_type_annotated_program=False, show_ast=False,
                 regenerate_type_inference_programs=False):
        """
        Buils a new Stypy type inference object instance for a certain source program. Creating an equivalent type
        inference program.
        :param source_file_path: Source program to process and calculate its type inference program
        :param python_exe: Python implementation to use (optional, initialized by default to the PYTHON_EXE stypy
        parameter)
        :param verbose: Output verbosity (True/False)
        :param generate_type_data_file: Optionally generate a type data file to perform unit testing over the
        generated type inference program. Defaults to False
        :param generate_type_annotated_program: Optionally generate a type annotated source file from the original one.
        Defaults to False
        :param show_ast: Display the AST of the processed source file. Defaults to False
        :return:
        """
        self.python_exe = python_exe
        self.validation_error = ""
        self.source_file_path = source_file_path
        self.file_ = open(self.source_file_path, 'r')
        self.original_program_src = self.file_.read()
        self.regenerate_type_inference_programs = regenerate_type_inference_programs

        # Configure all FunctionContext and TypeInferenceProxy objects to use type annotation, that will be later used
        # to create type annotated source files
        type_store_copy.funcion_context_copy.FunctionContext.annotate_types = generate_type_annotated_program
        type_inference_copy.type_inerence_proxy_copy.TypeInferenceProxy.annotate_types = generate_type_annotated_program

        # Output configuration
        self.verbose = verbose
        Stypy.__configure_stypy_output(verbose)

        try:
            # Read the program AST
            self.original_ast_tree = self.__read_new_ast_from_file()
        except Exception as exc:
            error("Python is unable to compile the input file '{0}':\n".format(self.source_file_path) + str(exc))
            exit(-1)

        # Sequence of source visitors that will be applied over the original program AST. Those visitor transform the
        # program code in various ways, aiming to facilitate the type inference program generation when dealing with
        # some Python constructs. Visitors are processed in declaration order. The last one should be the
        # TypeInferenceGeneratorVisitor, that is in charge of generating the type inference program.
        self.visitors = [
            multiple_assignments_visitor_copy.MultipleAssignmentsDesugaringVisitor(),
            class_attributes_visitor_copy.ClassAttributesVisitor(),
            class__init__visitor_copy.ClassInitVisitor(),
            type_inference_visitor_copy.TypeInferenceGeneratorVisitor(self.source_file_path.split('\\')[-1],
                                                                 self.original_program_src),
        ]

        # Have I got to generate a type data file? If yes, use the visitor that transform the original program into
        # a derived one that captures runtime variable values during execution
        if generate_type_data_file:
            self.type_data_autogeneration_ast_tree = TypeDataAutoGeneratorVisitor().visit(
                self.__read_new_ast_from_file())
            ast.fix_missing_locations(self.type_data_autogeneration_ast_tree)
            self.type_generation_source_code = None

        # Member initialization
        self.type_inference_ast_tree = None
        self.type_inference_source_code = None
        self.generate_type_data_file = generate_type_data_file
        self.show_ast = show_ast
        self.generate_type_annotated_program = generate_type_annotated_program
        self.tinit = 0
        self.tend = 0

        # Program analysis output results
        self.analyzed_program_type_store = None
        self.analyzed_program_errors = None
        self.analyzed_program_warnings = None

    def set_source_file_path(self, source_file_path):
        """
        Changes the source file of the program to be processed
        :param source_file_path: File path
        :return:
        """
        self.source_file_path = source_file_path
        self.file_ = open(self.source_file_path, 'r')
        self.original_program_src = self.file_.read()

    ###################################### ORIGINAL SOURCE FILE ######################################

    def get_original_source_file_ast(self):
        """
        Get the original source file AST tree optionally showing it
        :return:
        """
        if self.verbose:
            info("\nSTyPy: Calculating program AST...\n")
        original_ast = self.__get_original_source_file_ast()
        if self.show_ast:
            info(dump_ast(original_ast))

        return original_ast

    ###################################### TYPE DATA FILE AUTOGENERATION ######################################

    def get_type_data_autogeneration_ast(self):
        """
        Get the AST of the optionally generated runtime type data calculation program
        :return:
        """
        if not hasattr(self, "type_data_autogeneration_ast_tree"):
            return None
        return self.type_data_autogeneration_ast_tree

    def get_type_data_autogeneration_program_source_code(self):
        """
        Get the source code of the optionally generated runtime type data calculation program
        :return:
        """
        if not hasattr(self, "type_generation_source_code"):
            return None

        if self.type_generation_source_code is None:
            self.type_generation_source_code = PythonSrcGeneratorVisitor(
                self.get_type_data_autogeneration_ast()).generate_code()

        return self.type_generation_source_code

    def create_automatic_type_data_autogenerator_program(self):
        """
        Creates a runtime type data calculation program derived from the original one, used for unit testing
        :return:
        """
        if os.path.exists(get_stypy_type_data_file_path(self.source_file_path)):
            return

        info("\nSTyPy: Calculating automatic type information helper program AST...\n")
        tt_ast = self.get_type_data_autogeneration_ast()
        if tt_ast is None:
            return
        if self.show_ast:
            info(dump_ast(tt_ast))

        info("\n\n")

        info("\nSTyPy: Automatic type information helper program code:\n")
        tgen_source = self.get_type_data_autogeneration_program_source_code()
        info(tgen_source)
        write_python_source_code(get_stypy_type_data_autogenerator_program_file_path(self.source_file_path),
                                 tgen_source)

        if not os.path.exists(get_stypy_type_data_file_path(self.source_file_path)):
            self.__run_program(get_stypy_type_data_autogenerator_program_file_path(self.source_file_path))

    ###################################### TYPE INFERENCE PROGRAM ######################################

    def get_type_inference_program_ast(self):
        """
        Get the generated type inference program AST
        :return:
        """
        if self.type_inference_ast_tree is None:
            self.type_inference_ast_tree = self.original_ast_tree

            # Apply each visitor in declaration order
            for visitor in self.visitors:
                if self.verbose:
                    info("USING '{0}' VISITOR\n".format(type(visitor).__name__))

                # Visitor is a NodeVisitor that generate a new tree from the original one without changing it.
                # Replace the current one for the next iteration once finished
                if isinstance(visitor, ast.NodeVisitor):
                    temp_tree = visitor.visit(self.type_inference_ast_tree)
                    self.type_inference_ast_tree = temp_tree
                else:
                    # Modify nodes of the existing tree (visitor is a NodeTransformer)
                    visitor.visit(self.type_inference_ast_tree)

                if self.show_ast:
                    info(dump_ast(self.type_inference_ast_tree))
            try:
                # This is needed for proper source code generation from the generated AST tree
                ast.fix_missing_locations(self.type_inference_ast_tree)
            except:
                pass

        return self.type_inference_ast_tree

    def get_type_inference_program_source_code(self):
        """
        Generates the source code for the type inference program, once its AST has been calculated
        :return:
        """
        if self.type_inference_source_code is None:
            self.type_inference_source_code = PythonSrcGeneratorVisitor(
                self.get_type_inference_program_ast()).generate_code()

            for visitor in self.visitors:
                if isinstance(visitor, type_inference_visitor_copy.TypeInferenceGeneratorVisitor):
                    self.type_inference_source_code += type_inference_visitor_copy.TypeInferenceGeneratorVisitor.get_postfix_src_code()
                    break

        return self.type_inference_source_code

    def create_type_inference_program(self):
        """
        Perform the full cycle of generating the type inference program AST (get_type_inference_program_ast) -
        generate the source code from this AST (get_type_inference_program_source_code) - write this source code to a
        file (write_python_source_code). This method should be called when generating the type inference program from
        a Python source file, instead of the individual ones, provided in a public fashion just for logging purposes.
        :return:
        """
        # if not self.regenerate_type_inference_programs:
        #     if os.path.isfile(get_stypy_type_inference_program_file_path(self.source_file_path)):
        #         return

        if self.verbose:
            info("\nSTyPy: Calculating type inference program AST...\n")
        ti_ast = self.get_type_inference_program_ast()

        if self.show_ast:
            info(dump_ast(ti_ast))

        if self.verbose:
            info("\n\n")
            info("\nSTyPy: Type inference program source code:\n")

        tinf_source = self.get_type_inference_program_source_code()
        info(tinf_source)

        write_python_source_code(get_stypy_type_inference_program_file_path(self.source_file_path), tinf_source)

    ###################################### RUN TYPE INFERENCE ######################################

    def __run_type_inference(self):
        """
        Runs the type inference program of the source represented by this Stypy object, generating a type data file
        (if it does not exist) in order to test the type inference results against these data, provided this option
        is enabled. Finally, it generates the equivalent type annotated program, if this option is enabled.
        :return:
        """
        if self.verbose:
            info("\nSTyPy: Running type inference program...\n")

        # TODO: Remove
        # if self.generate_type_data_file:
        #     # Do we already have a type data file?
        #     if not os.path.exists(get_stypy_type_data_file_path(self.source_file_path)):
        #         try:
        #             # If not, create a runtime type data calculation program and run it
        #             self.__run_type_inference_program(
        #                 get_stypy_type_data_autogenerator_program_file_path(self.source_file_path))
        #         except:
        #             pass

        # result = compile(self.type_inference_ast_tree, '<string>', 'exec') # compile the module AST
        # Run the generated type inference program to look for errors
        self.__run_type_inference_program(get_stypy_type_inference_program_file_path(self.source_file_path))

        # Create a type annotated program from the original source file
        if self.generate_type_annotated_program:
            self.create_type_annotated_program()

    def create_type_annotated_program(self):
        """
        Creates a type-annotated version of the analyzed Python program.
        :return:
        """
        my_type_store = self.get_analyzed_program_type_store()
        # Visit the source code with the analyzed program type store with the inferred types, so we can place type
        # annotations in the correct source lines
        annotator_visitor = TypeAnnotationVisitor(self.source_file_path, my_type_store)

        annotated_tree = annotator_visitor.visit(self.__read_new_ast_from_file())
        if self.show_ast:
            info("Type annotated program AST: ")
            info(dump_ast(annotated_tree))

        try:
            ast.fix_missing_locations(annotated_tree)
        except:
            pass

        annotated_type_source_code = PythonSrcGeneratorVisitor(annotated_tree).generate_code()
        write_python_source_code(get_stypy_type_annotation_file_path(self.source_file_path),
                                 annotated_type_source_code)

        # Annotate the types of modules that the program uses
        for stypy_object in my_type_store.external_modules:
            stypy_object.create_type_annotated_program()

    def analyze(self):
        """
        Main stypy function. Performs all the step to analyze the source file types in order
        """
        if self.verbose:
            info("Parsing file '" + self.source_file_path + "'\n")

        existing_ts = typestore_copy.TypeStore.get_type_store_of_module(self.source_file_path)
        if existing_ts is not None:
            self.analyzed_program_type_store = existing_ts
            return existing_ts

        # Obtain the AST of the source file
        self.get_original_source_file_ast()

        # If a type data file have to be generated and the source file is suitable to do so, do it
        if self.generate_type_data_file:
            if Stypy.__is_file_suitable_for_autocalculate_types(self.source_file_path):
                self.create_automatic_type_data_autogenerator_program()

        # Create the type inference program
        self.create_type_inference_program()

        return self.__run_type_inference()

    ###################################### POST ANALYSIS DATA ######################################

    def get_analyzed_program_type_store(self):
        """
        Get the type store of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_type_store is None:
            self.analyze()

        return self.analyzed_program_type_store

    def get_analyzed_program_errors(self):
        """
        Get the type errors of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_errors is None:
            self.analyze()

        return self.analyzed_program_errors

    def get_analyzed_program_warnings(self):
        """
        Get the type warnings of the analyzed Python source file
        :return:
        """
        if self.analyzed_program_warnings is None:
            self.analyze()

        return self.analyzed_program_warnings

    def get_last_type_checking_running_time(self):
        """
        Get the time spent on the last Python source file analysis
        :return:
        """
        return self.tend - self.tinit
